# kernel

# 各种知识点

[kerknowledge](kerknowledge%2021cf8c7e8b9c8098bb4decedc0fe0a35.csv)

## 啥是内核

运行在计算机（虚拟机）中的操作系统内核

![image.png](image.png)

image-20241123175013166

strace 跟踪

![image.png](image%201.png)

![image.png](image%202.png)

```
callq <writeplt> //在libc.so中找到write接口->syscall
在内核栈帧保存rax rdi di dx ip-->> strap
将寄存器（当前状态）保存到msr寄存器
执行entry。。。
再将状态保存到pt_reg结构体
do syscall
swapgs 切回用户态
```

```
make menuconfig
make -j4 bzImage //只编译这部分就行
文件系统：
自己加文件系统 /bin/
bash 5.0兼容性不好 不如bash4.8，bash-4比sh好用，方便调试
strace调试exp用
lspci qemu时才用
```

系统调用进入内核态
中断与异常（interrupt & exception）：当 CPU 收到一个中断 / 异常时，会切换到 ring0，并根据中断描述符表索引对应的中断处理代码以执行。
特权级相关指令：当 CPU 运行这些指令时会发生运行状态的改变，例如 iret 指令（ring0->ring3）或是 sysenter 指令（ring3->ring0）。

## Linux 内核启动文件(qemu+普通内核)

### 运行过程

1. Bootloader 文件（引导程序）
在系统启动时，BIOS/UEFI 会先启动一个引导加载程序，通常是 GRUB、LILO 或 SYSLINUX 等。
- GRUB 配置文件：
    - `grub.cfg` 或 `/boot/grub/grub.cfg`：这是 GRUB 的配置文件，包含启动菜单、可启动的内核、内存盘映像及其参数。
    - 在 GRUB 启动时，它会读取此文件来展示启动菜单，并根据用户的选择加载对应的 Linux 内核和初始文件系统。
- **qemu**
1. 内核映像文件
引导程序加载**内核映像**到虚拟内存
- **bzImage/vmlinuz**：
Linux 内核的可引导文件。
包含了*启动代码*和*内核的核心部分*。
- 当 GRUB 加载这个文件时，它首先解压缩自己，然后`开始执行内核代码`
1. 初始 RAM 磁盘（Initial RAM Disk）文件
在内核启动后，内核通常会加载一个**初始文件系统**，以便它可以访问基本的设备驱动程序和挂载真正的根文件系统。
- **initrd/initramfs**：
被解压缩到内存中，提供内核启动过程中所需的文件系统。
这个文件可以是 `.img` 格式，也可以是 `.gz`、`.cpio` 格式压缩的文件。
    - 典型的路径：`/boot/initrd.img-*` 或 `/boot/initramfs-*`
    - 例如，如果系统的根文件系统位于一个复杂的设备（如 LVM、RAID 或远程网络存储）上，initrd 或 initramfs 会包含相应的驱动程序和脚本以挂载这些设备。
1. 从.cpio挂载根文件系统
一旦内核和初始文件系统（initramfs/initrd）完成了启动，真正的根文件系统就需要被挂载。这是 Linux 系统运行时使用的主要文件系统。
2. 内核从 `initramfs` 切换到实际的根文件系统（如 `/dev/sda1` 上的 `ext4` 文件系统）。
3. 内核启动根文件系统上的初始化进程（如 `systemd` 或 `init`），进入用户空间，启动系统服务。

![](https://i-blog.csdnimg.cn/blog_migrate/b276f27e2aa3a68a79e6e8407dc24cae.png#pic_center)

在这里插入图片描述

start_kernel函数

idle：pid=0,cpu空闲时运行，前身是唯一一个没有通过fork或者kernel_thread产生的进程。完成加载系统后，演变为进程调度、交换

kernel_init：pid=1，读取init，转到用户态

kthreadd：内核守护进程，管理和调度其他内核线程kernel_thread, 会循环执行一个kthreadd的函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程

1. 内核模块（.ko 文件）
内核本身只包含一些核心功能和驱动程序。其他功能（如网络驱动、文件系统支持）可以通过内核模块动态加载。
- 这些文件位于 `/lib/modules/$(uname -r)/` 目录下，表示内核模块的仓库。
- 在内核需要时，可以通过 `insmod`、`modprobe` 命令动态加载这些模块，添加新的硬件驱动支持或功能扩展，而无需重新启动内核。

### 内核参数和配置文件

在启动时，可以向内核传递参数，这些参数决定内核的一些行为。

- **GRUB 引导参数**：
    - 内核启动时，可以通过引导程序传递参数，这些参数可以控制内核功能。例如：
        - `root=/dev/sda1`：指定根文件系统的位置。
        - `ro`：启动时挂载根文件系统为只读模式。
        - `quiet`：减少启动过程中的输出信息。
        - `init=/bin/systemd`：指定启动的初始化进程。
    - 这些参数通常通过 GRUB 的配置文件（`grub.cfg`）传递。
- **根文件系统（root filesystem）**：
    - 根文件系统包含所有的用户空间工具、配置文件、库、可执行文件等，是操作系统运行时的核心环境。
    - 常见的根文件系统格式有：`ext4`、`xfs`、`btrfs` 等。
    - 根文件系统可能位于不同的存储设备上，如：
        - 本地硬盘（例如 `/dev/sda1`）
        - 网络存储（如 NFS 根文件系统）
        - 虚拟磁盘（如 LVM 或 RAID）

## kernel题目

### 题目文件有什么

1. start.sh(根据情况改改)

```
-m：虚拟机内存大小（如果启动的内核一直在重启，是内存恐慌，内存调大就行）
-kernel：内存镜像路径
-initrd：磁盘镜像路径
-append：附加参数选项nokalsr：关闭内核地址随机化，方便我们进行调试
rdinit：指定初始启动进程，/sbin/init进程会默认以 /etc/init.d/rcS 作为启动脚本
loglevel=3& quiet：不输出log
console=ttyS0：指定终端为/dev/ttyS0，这样一启动就能进入终端界面
-monitor：将监视器重定向到主机设备/dev/null，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag
-cpu：设置CPU安全选项，在这里开启了smep保护（smep保护就不能采用ret2usr手法了）
-s：相当于-gdb tcp::1234的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试
```

1. vmlinux(编译出来的最原始的内核文件，elf)：
    
    由于 bzImage 是压缩过的内核镜像，因此需要获取未经压缩的 `vmlinux` 镜像用于提供调试符号，以及查找 gadget 和关键结构偏移
    –objcopy+压缩->vmlinuz
    –gzip压缩->内核镜像bzimage
    磁盘镜像cpio（打包的初始文件系统（运行环境？））
    
2. bzlmage
    
    ```
    file bzImage
    strings bzImage | grep gcc
    ```
    

### 获取vmlinux的方式：

- 编译对应版本内核（bzimage）（还挺麻烦）
    
    可以编译出带调试符号的文件，gdb 调试的时候可以查看源码
    
    结构体相关的调试符号只有编译内核可以获得
    

```
wget https://test.com/archive.tar.gz
16 4.4.0
18 4.15
20 5.4
22 5.15/5.19
24 6.？
```

- vmlinux-to-elf ./bz vm
    
    带symbol names
    
- extract
    
    ```
    ./extract-vmlinux ./bzImage > vmlinux
    ```
    
- 直接下载镜像（高版本？）

### 获取gadgets

- ROPgadget –binary ./vmlinux > rop_all.txt（找gadget）
- ropper -f vmlinux —nocolor > rop_all.txt

### 将文件系统解压到temp文件夹（便于重新打包）

```bash
mkdir temp
解压到tempcp ../../others/* ./temp/
```

```
* gunzip -c core.cpio > coregz.cpio（gz）
* cpio -idmv < ./coregz.cpio
```

#-i：表示解包模式（extract mode）。
#-d：表示创建目录（create directories）。如果归档中包含目录，而这些目录在目标位置不存在，-d 选项会让 cpio 自动创建这些目录。
#-v：表示详细模式（verbose mode）。启用详细模式后，cpio 会在解包过程中显示处理的文件名。

### 修改成便于调试的样子，重新打包，运行查看调试信息

1. 要加入的脚本：
    
    pack.sh（打包用的，和run.sh放在一个文件也行）
    gdb.sh
    exp.c(为了减小远程exp的体积，可使用musl进行静态编译)
    
2. checksec 内核模块.ko：
    
    可看作是运行在内核空间的可执行程序，类似于 Linux 下的 ELF
    
    它在运行时被链接到内核作为内核的一部分在内核空间运行
    
3. 修改+调试：

### 修改init.sh以便调试:

- #poweroff
setsid /bin/cttyhack setuidgid 1000 /bin/sh(改成0可以root启动)
- 关kaslr+查看内核基地址：cat /proc/kallsyms | grep “startup”
    - ffffffff81000000 T startup_64
- restrict：
    
    1 非root不能看
    
    0 非root可以看
    

### 运行，查看各种地址

- 查看ko文件加载的地址：
    
     lsmod 
    
    - babydriver 16384 0 - Live 0xffffffffc0000000 (OE)
    
    或cat /sys/module/core/sections/.text 大部分函数都在这里
    
- 调试时可在init中加入：cat /proc/kallsyms > /tmp/kallsyms
    - 内核中所有符号的地址
- gdb后加载符号表:
    
    ```cpp
    // #!/bin/sh
    // gdb -q \
    //     -ex "file vmlinux" \
    //     -ex "add-symbol-file ./vuln.ko 0xffffffffc0000000  -s .data 0xffffffffc0002000 -s .bss 0xffffffffc0002400" \
    //     -ex "target remote localhost:1234" \
    //  #   -ex "b ioctl" \
    
    ```
    

## 内存布局 64

[虚拟地址（K U）↔物理地址 映射](https://www.notion.so/K-U-20bf8c7e8b9c8098b3f5c7cab8d882e7?pvs=21)

[](https://pic1.zhimg.com/70/v2-4881dcc0e058eed06860540046417904_1440w.image?source=172ae18b&biz_tag=Post)

![](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/ret2dir-rop.png)

Low Addresses (用户空间)
|——————————————————————|
0x0000000000000000 -> 用户空间，进程使用（如堆栈、数据段、代码段等）

00007fffffffffff
|——————————————————————|
0xffff880000000000 -> 内核空间开始
| Direct Mapping (直接映射区) -> 物理内存的直接映射(kamlloc)
ffffc7ffffffffff
|——————————————————————|
ffffc90000000000
| vmalloc Area (虚拟内存分配区) -> 动态分配的非连续虚拟内存
ffffe8ffffffffff

ffffea0000000000
| virtual内存映射
ffffeaffffffffff
|——————————————————————|
0xffffffff80000000
| Kernel
Text

Data
heap
stack
0xffffffffa0000000
|——————————————————————|
0xffffffffa0000000
| Module Area (内核模块区) -> 动态加载的内核模块（加载.ko文件）
| 系统调用表
0xffffffffffdfffff
|——————————————————————|
| IOREMAP (设备内存映射区) -> 设备寄存器映射
|——————————————————————|
High Addresses (内核空间)

## 保护

### .ko的保护

### kaslr（地址随机化）(leak memory)

- 在未开启 KASLR 保护机制时，内核代码段的基址为 0xffffffff81000000 ，direct mapping area 的基址为 0xffff888000000000
    - `关kaslr+查看内核基地址：cat /proc/kallsyms | grep "startup"`
        - ffffffff81000000 T startup_64
- 如果开了kaslr，需要泄露（）地址
    - 基地址（便于使用rop）
    - 堆地址
    - 栈地址？
- 怎么泄露
    - 直接读notes（或其他文件？）
    - 利用结构体

### FGKASLR

防止泄露地址得到整个内核地址布局，以函数粒度重新排布内核代码

### STACK PROTECTOR

### smap/smep(supervisor mode execution)

- cpu kvm64,+smep

在启动时，可以通过在-cpu选项下加入+smep来启用该防御机制

在-append选项下加入nosmep来禁用该机制。

禁止访问/执行用户空间

```
ret2usr
creds
______________kernel mode

shellcode     user mode
```

### kpti(内核页表隔离) （≥4.15）(不能ret2usr)

Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110

```
/home/pwn # dmesg | grep 'page table'
[    0.000000] Kernel/User page tables isolation: enabled
/home/pwn # cat /proc/cpuinfo | grep pti
fpu_exception   : yes
flags           : ... pti smep smap
```

开启kpti时，内核将用户映射表和内核映射表分开储存，两页表严格隔离

rop链使用 ireq返回用户态，仍使用内核映射表

所以还**需要将用户进程的页表给切换回来**，在 ROP 链中完成提权, 切换页表, 返回用户态这一系列工作

绕过kpti：

- signal(SIGSEGV, getRootShell);，重写段错误信号的处理函数，不切换页表，使 段错误→触发页表切换异常 时控制执行流，内核跳转到用户，从而绕过kpti。
- 

## cpu保护

```
$ cat /proc/cpuinfo
```

## 内核函数

- **所有的读取操作都可以通过对文件进行 read 系统调用完成**
- **所有的更改操作都可以通过对文件进行 write 系统调用完成**
- **所有的配置操作都可以通过对文件进行 ioctl 系统调用完成**

### Q:

怎么看交互的函数名-ida反汇编出来的基本就是，然后在kallsym里搜

怎么看fd在哪儿-init加载的文件名就是

### proc

进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量。当一个进程被建立起来时，其进程文件系统便会被挂载到`/proc/[PID]`下

proc_create()在procfs中创建虚拟文件，应用层通过**读写该文件，即可实现与内核的交互**

![image.png](image%203.png)

name：创建的文件名

mode：文件的访问权限，以UGO的模式表示，

parent与proc_mkdir中的parent类似，也是父文件夹的proc_dir_entry对象

fops结构体：定义了可以调用的函数，用于用户态与内核态的交流

![image.png](image%204.png)

譬如：proc_create(“core”, 438LL, 0LL, &core_fops)，core_fops中定义了core_write、ioctl、release函数

```
int fd = open("/proc/core", O_RDWR) //open函数打开core这个文件
write(fd, rop_chain, 0X800)调用core文件中core_write函数 //从用户(ropchain)向内核bss写入
```

### copy

copy_to/from_user(to,from, 64LL); 成功返回0，失败返回未复制的字节数

### ioctl

vfs_ioctl() 直接调用 unlocked_ioctl 函数

```
void core_read(int fd, char * buf)
{
    ioctl(fd, 0x6677889B, buf);
}
```

## exp(在内核root->回到用户态->执行shell)

kernel使用cred结构体记录了进程的权限，如果能劫持或伪造cred结构体，就能改变当前进程的权限。

### 状态保存

因此在我们的exploit进入内核态之前我们需要**手动模拟用户态进入内核态的准备工作**——**保存各寄存器的值到内核栈上**，以便于后续着陆回用户态

Iretq会恢复一系列的用户态寄存器值，因此，在程序一开始，我们就先利用内嵌汇编将几个重要的寄存器值保存到程序的变量里。Iretq的时候再放到rop里。

pushf将所有标志寄存器压栈

### 读取内核符号的地址

```
prepare_kernel_cred
				commit_creds //泄露
off = commit_creds - 0xffffffff8109c8e0（关kaslr，没有偏移的函数地址）;
vmlinux_base =  0xffffffff81000000 + off;
```

### 提权(在内核获取root权限)

内核驱动模块运行在内核空间，权限是root权限，因此我们将有机会借此拿到root权限的shell。

我们一般是写c程序去调用有漏洞的内核驱动（读写其proc文件），以便去拿到root权限

```c
system("bin/sh")->
	commit_creds(prepare_kernel_cred(&init_task))
	//或
	commit_creds(&init_cred)
	//或
	commit_creds(prepare_kernel_cred(NULL)) //高版本不能，因为在高版本的内核当中 prepare_kernel_cred(NULL) 将不再返回一个 root cred
	
//struct cred* prepare_kernel_cred(struct task_struct* daemon) —— 分配并返回一个新的cred
//commit_creds —— 应用新的cred
```

当成功执行如上函数之后，当前线程的 cred 结构体便变为 **init 进程的 cred** 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell

- kernel使用cred结构体记录了进程的权限，如果能劫持或伪造cred结构体使其uid和gid为0，就能改变当前进程的权限为root
    
    ```c
    struct cred {
        atomic_t    usage;
    #ifdef CONFIG_DEBUG_CREDENTIALS
        atomic_t    subscribers;    /* number of processes subscribed */
        void        *put_addr;
        unsigned    magic;
    #define CRED_MAGIC    0x43736564
    #define CRED_MAGIC_DEAD    0x44656144
    #endif
        kuid_t        uid;        /* real UID of the task */
        kgid_t        gid;        /* real GID of the task */
        kuid_t        suid;        /* saved UID of the task */
        kgid_t        sgid;        /* saved GID of the task */
        kuid_t        euid;        /* effective UID of the task */
        kgid_t        egid;        /* effective GID of the task */
        kuid_t        fsuid;        /* UID for VFS ops */
        kgid_t        fsgid;        /* GID for VFS ops */
        unsigned    securebits;    /* SUID-less security management */
        kernel_cap_t    cap_inheritable; /* caps our children can inherit */
        kernel_cap_t    cap_permitted;    /* caps we're permitted */
        kernel_cap_t    cap_effective;    /* caps we can actually use */
        kernel_cap_t    cap_bset;    /* capability bounding set */
        kernel_cap_t    cap_ambient;    /* Ambient capability set */
    #ifdef CONFIG_KEYS
        unsigned char    jit_keyring;    /* default keyring to attach requested
                         * keys to */
        struct key    *session_keyring; /* keyring inherited over fork */
        struct key    *process_keyring; /* keyring private to this process */
        struct key    *thread_keyring; /* keyring private to this thread */
        struct key    *request_key_auth; /* assumed request_key authority */
    #endif
    #ifdef CONFIG_SECURITY
        void        *security;    /* subjective LSM security */
    #endif
        struct user_struct *user;    /* real user ID subscription */
        struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
        struct group_info *group_info;    /* supplementary groups for euid/fsgid */
        /* RCU deletion */
        union {
            int non_rcu;            /* Can we skip RCU deletion? */
            struct rcu_head    rcu;        /* RCU deletion hook */
        };
    } __randomize_layout;
    ```
    
- prepare_kernel_cred —— 分配并返回一个新的cred
commit_creds —— 应用新的cred
- uid gid 用户id和组id，全为零是最高权限

### 布置寄存器 返回用户态，起shell

返回用户态用到swapgs和iretq这两条指令，在gadgets里能够找到。

- 切换gs寄存器，回到用户页表→iretq正式返回用户态

```nasm
  swapgs  //恢复用户态gs寄存器
  
  popfq ret//从栈顶弹出一个值恢复到 RFLAGS
  0
  iretq   //或sysretq，pop5个寄存器恢复用户空间(用户态寄存器值是下面那些)
      
    user_getshell_addr//ip
    user_cs
    user_eflags //64bit user_rflags
    user_sp
    user_ss
```

- swapgs：
    - 在 x86-64 架构下，内核和用户态通常使用不同的 `GS` 段基址（内核态 `GS` 可能指向 per-CPU 数据区，用户态 `GS` 可能用于线程局部存储）。
    - 在执行 `iretq` **之前**，必须执行 `swapgs` 指令。这条指令会交换 `MSR_KERNEL_GS_BASE` 和 `MSR_GS_BASE` 寄存器的内容，将 `GS` 基址恢复成用户态的值。如果不执行 `swapgs`，返回用户态后，`GS` 基址仍然是内核态的值，访问用户态内存（尤其是 libc 等库函数）时很可能会因为错误的 `GS` 基址而崩溃。

（或者`swapgs_restore_regs_and_return_to_usermode`函数，直接对`CR3`寄存器的第13位取反来完成切换页表的操作，该函数在KPTI开启的版本中依然有效，而swapgs往往会寄）

- IRET(interrupt return)：
    
    pop许多东西，使程序返回到原来发生中断的地方。其作用是**从中断中恢复**中断前的状态
    
    1.恢复IP(instruction pointer)：IP←（（SP）+1:（SP）），SP←SP+2
    2.恢复CS(code segment)：CS←（（SP）+1:（SP））， SP←SP+2
    3.恢复中断前的PSW(program status word),即恢复中断前的标志寄存器的状态。
    FR←（（SP）+1:（SP）），SP←SP+2
    4.恢复ESP（返回权限发生变化）
    5.恢复SS（返回权限发生变化）
    
- sysretq：
    
    `sysretq` 是 `syscall` 指令的配对返回指令，它更快但对寄存器有特定要求（`RCX`存返回地址，`R11`存 RFLAGS）
    

![](https://i-blog.csdnimg.cn/blog_migrate/f547c67fe9d872479f36f761f94b8a34.png)

img

ret

retf

## 页表转换

用户转内核

虚拟地址转物理地址

# 题目类型

## ret2usr（无kpti）

无smep/smap，内核可以访问/执行用户空间。kernel rop返回用户空间（通过在内联汇编中挪动rsp（这能行？））执行提权的函数

```c
void getRootPrivilige(void)//就是commit(prepare...(0)),没啥
{
    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
}
```

swapgs iret

用户态getshell

复位寄存器

## ret2usr+bypass_smep

改变cr4寄存器第20 21位为0

用rop：

- 用与运算将 SMEP 与 SMAP 的两位给清除掉
- 直接给 cr4 赋值 `0x6f0` 也是可以的（通常关了以后都是这个值）

`swapgs_restore_regs_and_return_to_usermode` 来返回用户态

![image.png](image%205.png)

高版本内核无cr4指令，要手动添加

## 内核rop

有smep行不行？毕竟拿shell之前全程都在内核态

```c
    ropchain[i++] = POP_RDI_RET + offset;    
    ropchain[i++] = 0;    
    ropchain[i++] = prepare_kernel_cred;    
    ropchain[i++] = POP_RDX_RET + offset;    
    ropchain[i++] = POP_RCX_RET + offset; 
    // clear useless stack data    
    ropchain[i++] = MOV_RDI_RAX_CALL_RDX + offset;//pop_rcx    
    ropchain[i++] = commit_creds;//ret    
    ropchain[i++] = SWAPGS_POPFQ_RET + offset;    
    ropchain[i++] = 0;    
    ropchain[i++] = IRETQ + offset;    //或swapgs_restore_regs_and_return_to_usermode    
    ropchain[i++] = (size_t)get_root_shell;//此时页表寄存器还是指向内核映射表，但此地址不在内核映射表中，kpti开启时会报错    
    ropchain[i++] = user_cs;    
    ropchain[i++] = user_rflags;   
     ropchain[i++] = user_sp;    
     ropchain[i++] = user_ss;
```

```
1、保存返回用户态所需的寄存器信息
2、利用core_read leak canary
3、通过/tmp/kallsyms中的信息获取函数地址与计算ropgadget的偏移/*****/
4、利用core_copy_func函数存在的栈溢出控制内核程序流完成提权（commit_cred(prepare_kernel_cred(NULL))
并返回用户态执行shell（iretq）
```

在内核态触发漏洞，执行rop

## bypass kpti

## ret2dir

开启smep/smap/pxn时，内核不能直接访问用户地址，可通过ret2dir访问内核空间的用户数据。

在用户空间中布置的 gadget 可以通过 direct mapping area （ffff8880 00000000~ ffffc87f ffffffff ）上的地址**在内核空间中访问到**

低版本directmapping有执行权限，可布置shellcode；高版本需布置rop

![](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/figure/ret2dir-rop.png)

image.png

这块区域的存在意味着：对于一个被用户进程使用的物理页框，**同时存在着一个用户空间地址与内核空间地址到该物理页框的映射**，即我们利用这两个地址进行内存访问时访问的是同一个物理页框

```
1. 利用 mmap 在用户空间大量喷射内存
2. 利用漏洞泄露出内核的堆上地址（kmalloc），这个地址直接来自于线性映射区
3. 利用泄露出的内核线性映射区的地址进行内存搜索，从而找到在用户空间喷射的内存
```

内存搜索可以用 physmap spray 来代替，就是说使用 **mmap 喷射大量的物理内存**写入同样的 **payload**，之后随机挑选一个线性映射区上的地址进行利用

addr1->addr2<- sth to execve，传入addr1

1_kernel_physmap(64T)->2_dir

以页为单位开辟内存，循环写入，能在直接映射区找到写入的东西（布置rop

接着需要将内核栈的空间迁移到`phsymap`上（执行rop）

需要在栈上填入`phsymap`的地址，经add rsp xxx;ret后指向**physmap地址**（存在 内核栈上的 pt_regs 内）

向寄存器填入数据，测试pt_reg这个结构体在栈上的位置

### 高版本没有的gadgets

### mov rdi,rax;

–>> commit_cred(init_cred) 在.data段，表示root权限的cred结构体

为啥能用这个？题里给了？

### iretq;

–>> swapgs_restore_regs_and_return_to_usermode（位于 arch/x86/entry/entry_64.S）

内核代码中有一个 `swapgs_restore_regs_and_return_to_usermode` 函数实现了切换页表, 返回用户态的操作

```
; —— 第一段：从栈恢复寄存器，并跳回调用点 ——  
    pop     r15                   ; 恢复 r15  
    pop     r14                   ; 恢复 r14  
    pop     r13                   ; 恢复 r13  
    pop     r12                   ; 恢复 r12  
    pop     rbp                   ; 恢复 rbp  
    pop     rbx                   ; 恢复 rbx  
    pop     r11                   ; 恢复 r11  
    pop     r10                   ; 恢复 r10  
    pop     r9                    ; 恢复 r9  
    pop     r8                    ; 恢复 r8  
    pop     rax                   ; 恢复 rax  
    pop     rcx                   ; 恢复 rcx  
    pop     rdx                   ; 恢复 rdx  
    pop     rsi                   ; 恢复 rsi  
    mov     rdi, rsp              ; 将当前栈顶（原返回地址处）加载到 rdi  
    jmp     <target_function>     ; 跳回到刚才从栈拿到的返回地址  

; —— 第二段：根据刚才保存的 RSP（在 gs:0x6004）恢复用户态上下文 ——  
loc_FFFFFFFF81200F89:  
    mov     rsp, qword ptr gs:0x6004  ; 从 GS 段基址的偏移 0x6004 取出用户 RSP  
    push    qword ptr [rdi + 0x30]     ; 按原序将各寄存器值压栈，恢复用户态上下文  
    push    qword ptr [rdi + 0x28]  
    push    qword ptr [rdi + 0x20]  
    push    qword ptr [rdi + 0x18]  
    push    qword ptr [rdi + 0x10]  
    push    qword ptr [rdi]  
    push    rax                        ; 最后再推入 RAX  
    jmp     short loc_resume_user      ; 跳到恢复用户态执行的 stub  

; —— 第三段：切换到原 CR3 并执行 iretq ——  
loc_resume_user:  
    mov     rdi, cr3                   ; 将当前 CR3（页表基址）放到 RDI  
    or      rdi, 0x1000                ; 恢复原来用户页表的位（示例掩码）  
    mov     cr3, rdi                   ; 切换到用户态页表  
    pop     rax                        ; 弹出之前 push 的 RAX  
    pop     rdi                        ; 弹出之前 push 的 RDI （指向用户上下文）  
    swapgs                             ; 切换 Gs 段基址回用户态  
    iretq                              ; 从特权级 0 返回到用户态（恢复 RIP/RCS/RFLAGS）  

```

### trivia

![image.png](image%206.png)

![image.png](image%207.png)

call__x86_indirect_thunk_rbx

![image.png](image%208.png)

```cpp
echo 1 > /proc/sys/kernel/kptr_restrict
地址
echo 1 > /proc/sys/kernel/dmesg_restrict
dmesg
echo 1 > /proc/sys/kernel/perf_event_paranoid
无法分析内核函数或系统中其他进程的 CPU 使用情况
echo 1 > /proc/sys/vm/unprivileged_userfaultfd
禁止非特权用户使用 userfaultfd() 系统调用
```